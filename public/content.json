{"meta":{"title":"Hexo","subtitle":"","description":"","author":"Semon","url":"http://mingliang233.com","root":"/"},"pages":[],"posts":[{"title":"Hello World","slug":"hello-world","date":"2020-07-26T04:14:29.936Z","updated":"2020-07-26T04:14:29.936Z","comments":true,"path":"2020/07/26/hello-world/","link":"","permalink":"http://mingliang233.com/2020/07/26/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"面试题","slug":"面试题","date":"2020-05-22T00:47:12.519Z","updated":"2020-05-24T16:35:02.647Z","comments":true,"path":"2020/05/22/面试题/","link":"","permalink":"http://mingliang233.com/2020/05/22/%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"","text":"1、实现N的阶乘 public static int factorial(int n) { if (n &lt;= 0) { return 1; } return n * factorial(n - 1);}public static int factorial2(int n) { if (n &lt;= 0) { return 1; } else { int sum = 1; while (n &gt; 1) { sum *= n; n–; } return sum; } }2、抽象类和接口的区别 抽象类：可以有构造函数，但是不能实例化。可以有抽象方法和非抽象方法。缺点是实现类只能单继承 接口：没有构造函数方法默认为 public abstract成员变量默认为public static final1.8之后也可以有default和static修饰的成员方法，default方法目的是默认实现，不破坏现有代码，default方法中可以调用static方法另外：abstract的方法不能被static，native，synchronized和final修饰3、实现饿汉懒汉单例模式 懒汉式：public class Singleton { private static Singleton singleton; private Singleton() { } public static Singleton getInstance() { if (singleton == null) { return new Singleton(); } return singleton; }}饿汉式：public class Singleton2 { private static Singleton2 instance = new Singleton2(); private Singleton2() { } public static Singleton2 getInstance() { return instance; }}4、一个类存为hashmap的key要重写哪些方法？需要重写equals和hashcode方法 1、为什么要重写 2、怎么重写5、不会改变。因为传递的是值。6、java中怎样加锁？ 7、ThreadPoolExecutor里面的各个参数含义？ int corePoolSize, //核心线程数int maximumPoolSize, //最大线程数目long keepAliveTime, //当超出核心线程数目时，这个参数开始起作用，表示多出来的线程存活时长TimeUnit unit, //时间单位BlockingQueue workQueue, //用来存储工作线程的队列，有LinkedBlockingQueue\\SynchronousQueueThreadFactory threadFactory, //RejectedExecutionHandler handler //拒绝策略,有CallerRunsPolicy,AbortPolicy,DiscardPolicy,DiscardOldestPolicy四种 https://www.cnblogs.com/baizhanshi/p/5469948.html8、Serial 收集器、ParNew 收集器、 Parallel Scavenge 收集器、Serial Old 收集器、Parallel Old 收集器、CMS 收集器、 G1 收集器 https://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md9、是有限的。受到栈空间大小的限制，超出限制会报StackOverFlow错误。可以通过-Xss来设置栈空间大小。10、cpu过高或者频繁GC怎样定位问题？11、简述spring IOC和AOP，项目中哪里使用了？spring ioc 是一种容器，实现了依赖注入，将new对象的操作交给spring管理，ioc来保存该对象。spring aop12、redis缓存与数据库一致性如何保证？redis数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。13、为什么使用反向代理？负载均衡、安全性14、原子性15、join默认是什么、其他类型的join?join默认是inner join16、有关系，查询的条件要和字段类型一致17、linux隐藏文件什么特点，如何显示ls 显示文件ls -a 显示文件和隐藏文件隐藏文件都以小数点 .开头 例如： .txt18、分布式系统数据一致性如何解决？分布式事务、分布式锁19、输入url经过哪些层？请求经过DNS解析，到nginx反向代理、转发路由静态代理：代理到静态资源，页面通过XHR请求后端动态代理：代理到tomcat/springboot服务、调用dao层/缓存层、返回结果 阿里一面： 自我介绍、自己做的项目和技术领域说一下sync的底层实现，锁优化，和lock的对比讲一下JVM参数调优详细过程为什么这么设置？好处是什么？描述gc场景，如何去分析gc日志？redis数据结构，使用场景，微博场景使用redis如何去设计用户关系？线程池参数设定，为什么这么设定，作用？7大参数spring的循环依赖如何解决？为什么要三级缓存？优先级队列的底层原理？阿里二面： 自我介绍一下吧聊项目结合你项目问你如何设计，提出漏洞，你怎么解决？如何改进，万一挂了？加一台机器有没有问题？如果我非要不出问题怎么办？高并发下单扣库存场景如何设计rocketMQ架构设计原理Dubbo框架实现原理最近读了什么书？平时怎么学习？常用的负载均衡，该怎么用，你能说下吗？阿里三面： 这一面主要问项目，给你的压力感比较强结合项目问，为什么这么设计？让你去优化，你怎么优化，引导你用一个合理的更好的方式去优化，数据库的设计等在公司做了什么事情，各个系统业务线都是做什么的，你的绩效，手写算法链表反转？阿里四面： JVM的主要组成部分及其作用？JVM运行时数据区包含哪些？JVM垃圾回收机制，何时触发MinorGC等操作JVM的垃圾回收算法：JVM 调优的工具？常用的JVM调优参数？堆栈的区别？详细介绍一下 CMS 垃圾回收器？怎么判断对象是否可以被回收？新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？java类加载过程?把你知道的中间件都说一下吧（瞬间懵了一下）HR面： 为什么来阿里？之前没考虑过阿里吗？毕业这么久了，你觉得自己最大的改变是什么？用一句话总结一下自己 问我看了啥书（设计模式，图解HTTP，Modern PHP…被打断然后开始问设计模式）美团点评二面面试题： 自我介绍进程调度、虚拟内存、进程与线程的区别、如何判断进程是否发生了内存泄漏常见的设计模式tcp与udp区别、tcp三次握手和四次挥手、流量控制、拥塞控制（四个算法，问得很细）分布式事务（并说一下2PC）、redis底层数据结构有哪些、持久化方式B+树索引和hash索引的区别redis分布式锁，其他实现方式，zookeeper如何实现的？分布式的一致性，强一致性和最终一致性Linux如何查看IO读写很高集群脑裂Linux中异步IO是如何实现的，消息队列如何实现的？Redis持久化，“并发高，数据量小”和“并发低，数据量大”，redis怎么选择存储模式Mysql主从复制原理，mysql中如何做故障转移（容灾）Nginx生命周期疫情期间，如果让你去调研所在城市口罩的可用量，有哪些方案？美团点评三面面试题： Java数据类型，同步机制hashmap correnthashmap？Threadlocal原理？讲讲贪心算法并发量很大，服务器宕机。你会怎么做？如果线上用户出现502错误你怎么排查？说一下你平时的学习方法？能告诉我你的博客地址吗？（当然可以啊，难道我要说不告诉你吗）syn和lock的区别，哪个更好？怎选择 三次握手，第三次失败了，失败怎么办？为什么四次挥手？hashmap源码，为什么8个节点变成红黑树 又为什么到了6个节点才恢复为链表？（泊松分布）缓存穿透，怎解决？负载均衡算法的实现轮询和随机的缺点？分布式服务治理dns迭代和递归的区别算法：最大回文串美团点评HR面： 自我介绍，抓住介绍的点让你详细说说？为什么实习经历只有一个月？为什么不去找其他的实习？其他的面试流程？考虑去哪里工作，北京是唯一选择吗？为什么来美团？你对美团技术团队的了解有多少？ 字节跳动一面面试题： 自我介绍聊聊项目，时间大概15种左右，面试官会根据项目的一些设计点来提问，提前做好准备，别自己坑了自己分布式锁是锁住一部分还是整个系统，既然是锁住整个，为什么不用消息队列？详细讲下怎么用 mq 实现的最终一致性，还有怎么利用的消息事务？tcp 于 http 的关系，如何基于 tcp 实现 httpJava 打开一个 http 流不关闭的后果io 流是基于抽象类还是接口实现的数据库的乐观锁和悲观锁是什么乐观锁实现原理，讲到一半，来写一个乐观锁吧java 的类中有什么方法线程安全是什么?volatile 和 synchorized 的区别假如有一个类 A 和一个 类 B，这两个类都有一个变量和一个自增操作，A 类的变量用 volatile 修饰，B 类没有用，B 类的自增操作用 synchorized 修饰，他们都是线程安全的吗，如果都是，那为什么要用 synchorized ，volatile 不是更轻量吗，synchorized 有什么作用。智力题：岛上有群人，各自戴着红帽子或者白帽子，但都不知道自己帽子颜色，只有知道自己帽子颜色，第二天才能出岛，这时候有个人进来说了句“你们之中至少有一个人戴了顶红帽子”，问岛上的人最后的离开情况算法：矩阵中的最长上升序列字节跳动二面面试题： 自我介绍项目介绍java集合框架全部介绍，从list set queue到maphashmap底层扩容线程安全问题如果一个对象 要作为hashmap的key需要做什么？Threadlocal类以及内存泄漏线程同步方式，具体每一个怎么做的jvm类加载双亲委派模式，有没有能破坏这个模式的方法？类加载整个过程解释垃圾回收算法，垃圾回收器有什么？synchronized用在静态和非静态方法的区别你做项目的思路是什么,看过什么源码，什么开源网站经常访间，看是什么学的的书不?字节跳动三面面试题： 问项目相关的技术栈（我回答的是MongoDB）怼问：为什么要用MongoDB？为什么不用MySQL？MongoDB有哪些特性，能说一下吗？文档型数据库有哪些？ES与MongoDB有什么区别？为什么ES搜索更快？数据库都有哪些类型，关系型数据库和NoSQL有什么区别？NoSQL有哪些？他们的使用场景都说一下问JVM，类加载到卸载的过程都说一下UML都有哪些图？如何从这些UML的图中来实现你的需求设计？设计模式说一下，Spring源码看过吧？那说一下设计模式是如何在Spring中体现的？Spring为什么要用简单工厂模式？微服务了解过吧(了解过一点)，微服务都有什么好处？微服务都有哪些框架或中间件？SpringCloud都有哪些组件啊？和阿里开源的这些有什么不同呢？如果要你用你该如何选择？SOA了解过吧？那什么是SOA？SOA与微服务相比有什么优缺点？如果让你提高一个系统，你该怎么做？如果让你设计一个系统，你要考虑哪些方面？对什么技术比较熟悉（回答的Java多线程），JDK提供了什么来实现线程安全啊？超线程是什么？知道吗？（顿时懵了，啥啊，没听过）对未来的技术有什么规划？你为什么要学这些技术？","categories":[],"tags":[]},{"title":"Spring中的设计模式","slug":"Spring中的设计模式","date":"2020-05-17T05:44:43.195Z","updated":"2020-05-17T14:44:47.256Z","comments":true,"path":"2020/05/17/Spring中的设计模式/","link":"","permalink":"http://mingliang233.com/2020/05/17/Spring%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"答：Spring是一个轻量级java开发框架。具有非侵入式的设计、通过控制反转降低代码耦合、声明式的事务管理、支持AOP等特点。框架中使用了很多设计模式。比如单例模式(spring bean)、工厂模式(BeanFactory )、模板模式(jdbcTemplete)、适配器模式(spring mvc)、策略模式、代理模式(aop)、装饰器模式(DataSource)。 单例模式单例模式是一种常用的创建型模式，他保证单个类再全局只能有一个由自己创建的实例，并提供一个全局访问点。单例模式分几种：懒汉式(线程不安全/安全)、饿汉式、双重检验锁式、注册式单例、枚举单例。 懒汉式单例：首先将构造器私有化(都需要私有化)，声明一个静态类对象instance，然后声明一个public静态获取instance的方法，判断instance==null时实例化。 由于线程不安全，我们在方法上加上synchronized锁来保证线程安全。 饿汉式：由于懒汉式直接在实例化方法上加了锁，效率会比较低。我们可以直接在声明静态类对象instance就完成初始化操作，这样利用了classLoader机制的静态资源只加载一次的特点来保证线程安全，提升了获取实例时的效率。 双重检验锁式：懒汉式并发效率不高，饿汉式没有实现延迟加载，我们可以实现双重检验锁的方式来兼顾这两点。(避免在类加载的时候就实例化，因为如果实例化instance很消耗资源，而实际运行时又用不到这个实力，那么明显很多资源是浪费的)。首先在懒汉式的基础上，在获取实例方法的内部先判断instance==null，如果为空再去加一个类锁。再次判断instance==null然后实例化。(再次判空的原因是第一个判断是先拦截一次，避免每次调用都实例化，并没有加锁，所以依然有线程安全问题) 容器式单例 spring当中装配bean使用的是注册表单例。 枚举式，Effective Java作者推荐方式，延迟加载，线程安全，防止序列化和反射多次实例化 工厂模式spring创建bean对象 代理模式AOP实现代理模式 观察者模式模板模式jdbcTemplete 适配器模式dispatcherServlet 策略模式装饰器模式","categories":[],"tags":[]},{"title":"分布式","slug":"分布式","date":"2020-05-11T14:48:07.142Z","updated":"2020-04-30T12:55:51.609Z","comments":true,"path":"2020/05/11/分布式/","link":"","permalink":"http://mingliang233.com/2020/05/11/%E5%88%86%E5%B8%83%E5%BC%8F/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"微服务","slug":"微服务","date":"2020-05-11T14:48:00.478Z","updated":"2020-04-30T12:55:51.609Z","comments":true,"path":"2020/05/11/微服务/","link":"","permalink":"http://mingliang233.com/2020/05/11/%E5%BE%AE%E6%9C%8D%E5%8A%A1/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Mybatis","slug":"Mybatis","date":"2020-04-30T13:26:04.808Z","updated":"2020-04-30T13:03:03.075Z","comments":true,"path":"2020/04/30/Mybatis/","link":"","permalink":"http://mingliang233.com/2020/04/30/Mybatis/","excerpt":"","text":"https://blog.csdn.net/qq_38762479/article/details/89306984https://blog.csdn.net/u012588160/article/details/100108895https://blog.csdn.net/u010970712/article/details/80042731https://docs.oracle.com/javase/specs/jvms/se14/html/index.htmlhttps://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md Cs-Noteshttps://www.bilibili.com/read/cv5216534/?spm_id_from=333.788.b_636f6d6d656e74.7 尚硅谷路线图2020https://www.cnblogs.com/onepixel/articles/7674659.html 排序算法https://computer.howstuffworks.com/ram.htm RAM工作原理","categories":[],"tags":[]},{"title":"Linux","slug":"Linux","date":"2020-04-30T13:03:54.112Z","updated":"2020-04-30T13:03:03.075Z","comments":true,"path":"2020/04/30/Linux/","link":"","permalink":"http://mingliang233.com/2020/04/30/Linux/","excerpt":"","text":"https://blog.csdn.net/qq_38762479/article/details/89306984https://blog.csdn.net/u012588160/article/details/100108895https://blog.csdn.net/u010970712/article/details/80042731https://docs.oracle.com/javase/specs/jvms/se14/html/index.htmlhttps://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md Cs-Noteshttps://www.bilibili.com/read/cv5216534/?spm_id_from=333.788.b_636f6d6d656e74.7 尚硅谷路线图2020https://www.cnblogs.com/onepixel/articles/7674659.html 排序算法https://computer.howstuffworks.com/ram.htm RAM工作原理","categories":[],"tags":[]},{"title":"学习链接","slug":"学习链接","date":"2020-04-30T13:02:46.332Z","updated":"2020-05-17T16:13:09.748Z","comments":true,"path":"2020/04/30/学习链接/","link":"","permalink":"http://mingliang233.com/2020/04/30/%E5%AD%A6%E4%B9%A0%E9%93%BE%E6%8E%A5/","excerpt":"","text":"https://blog.csdn.net/qq_38762479/article/details/89306984https://blog.csdn.net/u012588160/article/details/100108895https://blog.csdn.net/u010970712/article/details/80042731https://docs.oracle.com/javase/specs/jvms/se14/html/index.htmlhttps://github.com/CyC2018/CS-Notes/blob/master/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md Cs-Noteshttps://www.bilibili.com/read/cv5216534/?spm_id_from=333.788.b_636f6d6d656e74.7 尚硅谷路线图2020https://www.cnblogs.com/onepixel/articles/7674659.html 排序算法https://computer.howstuffworks.com/ram.htm RAM工作原理 http://www.masterraghu.com/subjects/np/introduction/unix_network_programming_v1.3/toc.html Unix网络编程电子书 https://github.com/haiyusun/coding-interviews 剑指offer答案","categories":[],"tags":[]},{"title":"设计模式","slug":"设计模式","date":"2020-04-30T12:59:21.906Z","updated":"2020-05-10T13:39:59.258Z","comments":true,"path":"2020/04/30/设计模式/","link":"","permalink":"http://mingliang233.com/2020/04/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"设计模式 public class Singleton { private static Singleton instance; private Singleton (){} public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } public class Singleton { private static Singleton instance; private Singleton (){} public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; }} public class Singleton { private static Singleton instance = new Singleton(); private Singleton (){} public static Singleton getInstance() { return instance; }} public class Singleton { private volatile static Singleton singleton; private Singleton (){} public static Singleton getSingleton() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; }} public class Singleton { private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } private Singleton (){} public static final Singleton getInstance() { return SingletonHolder.INSTANCE; }} public enum Singleton { INSTANCE; public void whateverMethod() { }}","categories":[],"tags":[]},{"title":"Java基础","slug":"Java基础","date":"2020-04-30T12:57:21.781Z","updated":"2020-04-30T14:40:40.054Z","comments":true,"path":"2020/04/30/Java基础/","link":"","permalink":"http://mingliang233.com/2020/04/30/Java%E5%9F%BA%E7%A1%80/","excerpt":"","text":"String1、为什么String类设计为final 1、String类型不可变才能维护一个String常量池。当两个String变量拥有同样的值时，可以将变量直接指向String常量池。 2、String类型不可变，所以创建的时候就计算了hashcode且不会再变，是得Hashmap中可以使用String作为可靠的Key。 Hashmap,ConcurrentHashMap","categories":[],"tags":[]},{"title":"数据结构和算法","slug":"数据结构和算法","date":"2020-04-30T12:57:00.938Z","updated":"2020-05-26T16:24:12.498Z","comments":true,"path":"2020/04/30/数据结构和算法/","link":"","permalink":"http://mingliang233.com/2020/04/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/","excerpt":"","text":"数据结构1、数组 2、链表 3、树 二叉树、二叉搜索树、AVL树、B树、B+树、红黑树、Trie树 前中后遍历、深度优先、广度优先 4、栈 5、队列 单向、双向 6、堆 小顶堆、大顶堆 7、图 有向图、无向图、Dijkstra、Floyd 8、哈希表 HashMap 排序算法比较1、冒泡 2、快排 3、简单插入排序 4、希尔排序 5、选择排序 6、堆排序 7、归并排序 非比较8、计数排序 9、基数排序 10、桶排序","categories":[],"tags":[]},{"title":"MQ","slug":"MQ","date":"2020-04-30T12:56:55.725Z","updated":"2020-06-15T16:31:02.416Z","comments":true,"path":"2020/04/30/MQ/","link":"","permalink":"http://mingliang233.com/2020/04/30/MQ/","excerpt":"","text":"1、kafka核心原理 2、 优势 3、 消息重复消费","categories":[],"tags":[]},{"title":"JUC","slug":"JUC","date":"2020-04-30T12:56:47.330Z","updated":"2020-04-30T12:55:51.609Z","comments":true,"path":"2020/04/30/JUC/","link":"","permalink":"http://mingliang233.com/2020/04/30/JUC/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"JVM","slug":"JVM","date":"2020-04-30T12:56:42.631Z","updated":"2020-04-30T12:55:51.609Z","comments":true,"path":"2020/04/30/JVM/","link":"","permalink":"http://mingliang233.com/2020/04/30/JVM/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Spring","slug":"Spring","date":"2020-04-30T12:56:03.050Z","updated":"2020-05-12T00:55:34.599Z","comments":true,"path":"2020/04/30/Spring/","link":"","permalink":"http://mingliang233.com/2020/04/30/Spring/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"MySQL","slug":"MySQL","date":"2020-04-30T12:55:51.609Z","updated":"2020-04-30T13:58:05.301Z","comments":true,"path":"2020/04/30/MySQL/","link":"","permalink":"http://mingliang233.com/2020/04/30/MySQL/","excerpt":"","text":"锁innoDB行锁1.记录锁record lock 2.间隙锁gap lock 只存在RR中3.临键锁next-key lock next-key lock = gap lock + record lock select … in share mode select … for update RR RC MVCC Read Uncommited Serilizeable 意向锁 排他锁 共享锁","categories":[],"tags":[]},{"title":"IO模型详解","slug":"IO模型详解","date":"2020-04-28T14:07:59.490Z","updated":"2020-05-06T15:42:02.979Z","comments":true,"path":"2020/04/28/IO模型详解/","link":"","permalink":"http://mingliang233.com/2020/04/28/IO%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"NIO是什么?定义：NIO(Non-blocking I/O,New I/O)即非阻塞I/O,属于IO模型的一种 分类：同步/异步 阻塞/非阻塞 I/O 首先什么是I/O操作?I/O(input/output),是机器获取和交换信息的主要渠道。 在操作系统执行I/O操作的时候,通常都会涉及到用户态(User Mode)和内核态(Kernel Mode)的转换。 对于一个input操作来说，通常有两个步骤。1、等待数据就绪 2、将数据从kernel缓冲复制到user缓冲 Unix(-like)系统下的五种基本I/O模型 blocking I/O 一种常见的I/O模型，进程在调用recvfrom之后就一直处于阻塞状态，直到内核进程返回执行结果。 nonblocking I/O 进程不断的调用recvfrom，内核在数据包就绪之前一直返回EWOULDBLOCK标识。数据包就绪之后再开始复制数据，完成后返回OK。 I/O multiplexing (select and poll) 在直接调用recvfrom之前，先调用select来确定数据报是否就绪，如果就绪了内核会返回一个readable标识。收到readable标识后再去调用recvform来通知内核执行复制操作。 总结：这个和第一个blocking I/O来比没啥太大优点，还多了一次系统调用。好处就是可以等待多个数据报就绪的结果了，然后哪个就绪了就处理哪个。 关于select,poll和epoll 他们都是用来监听文件描述符fd的系统调用方法。select和poll可以认为是一样的，都是使用轮询的方式来从很多fd中检查哪一个就绪了。由于时间复杂度为O(n)，不适合执行大量密集fd的监控,后来出现了时间复杂度为O(1)的epoll替代他们。它是一种类似订阅的实现, epoll 包括(epoll_create, epoll_ctl, epoll_wait) ,首先epoll_create建立一个epoll，epoll_ctl来设定要监控的fd类型和事件类型，epoll_wait来获取结果 signal driven I/O (SIGIO) 首先调用sigaction建立一个信号句柄，内核会立即返回，这个过程非阻塞。数据报就绪后，内核会给进程生成一个SIGIO，这个时候可以再去调用recvfrom asynchronous I/O (the POSIX aio_ functions) 通过调用aio_read告知内核再整个input操作完成后(包括等待数据、复制到user缓冲)再通知，整个过程中进程是没有阻塞的，是真正的异步操作。 POSIX如下规定： 一个同步IO操作让申请进程在I/O操作结束之前一直被阻塞，反之异步操作就是没有被阻塞。 所以说前面四种都是同步I/O，只有最后一个asynchronous I/O才是真正的异步I/O Java中的BIO，NIO，AIObio: 基于java.lang.io nio: java1.4后引入 java.lang.nio aio:Java 7引入 其他文件描述符(**file descriptor,FD,fildes**)是一个获取文件资源(或其他IO资源)的句柄(handle)，通常是一个非负整数 The Portable Operating System Interface (POSIX) :旨在维持操作系统兼容性的标准 参考文献： https://jvns.ca/blog/2017/06/03/async-io-on-linux--select--poll--and-epoll/ https://www.ibm.com/developerworks/cn/java/j-lo-javaio/index.html http://tutorials.jenkov.com/","categories":[],"tags":[]}],"categories":[],"tags":[]}