### 锁

### innoDB行锁



1.记录锁record lock

2.间隙锁gap lock

###### 只存在RR中

3.临键锁next-key lock

next-key lock = gap lock + record lock

select ... in share mode

select ... for update

RR RC

MVCC



Read Uncommited

Serilizeable



意向锁

排他锁

共享锁


## 数据库

#### 1、数据库设计的三大范式？

- 第一范式1NF: 数据表中的每一列(字段)，必须是不可拆分的最小单元，也就是确保每一列的原子性。如订单信息列为orderInfo = "DD1024 2018.5.18"，必须拆分为orderId和orderTime。
- 第二范式2NF: 在满足第一范式的基础上，表中的所有列都必需依赖于主键（和主键有关系），其他和主键没有关系的列可以拆分出去。通俗点说就是：一个表只描述一件事情。比如order表中有orderId、orderTime、userId和userName，只有前两列依赖于订单表，后两列需要拆分到user表中。
- 第三范式3NF: 在满足第二范式的基础上，要求数据不能有传递关系。表中的每一列都要与主键直接相关，而不是间接相关（表中的每一列只能依赖于主键）。比如order表中有orderId、orderTime、userId和userName，根据orderId可以查出userId，根据userId又可以查出userName，这就是数据的传递性，完全可以只留下userId这一列。

#### 2、MySql的事务隔离级别？推荐使用哪种？

- 读未提交
- 读已提交
- 可重复读
- 串行化

在具体解释上面的四个隔离级别前。有必要了解事务的**四大特性（ACID）**

[推荐阅读这篇博客](https://www.cnblogs.com/huanongying/p/7021555.html)

- 原子性（Atomicity）：事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。
- 一致性（Consistency）：事务开始前和结束后，数据的完整性约束没有被破环。比如A向B转了钱，转账前后钱的总数不变。
- 隔离性（Isolation）：多个用户并发访问数据数据库时，一个用户的事务不能被其他用户的事务所干扰，多个并发事务之间的数据相互隔离。比如事务A和事务B都修改同一条记录，这条记录就会被重复修改或者后者会覆盖前者的修改记录。
- 持久性（Durability）：事务完成后，事务对数据库的更新被保存到数据库，其结果是永久的。

事务并发可能产生的问题：
脏数据：事务对缓冲池中的行记录进行修改，但是还没有被提交。

- 脏读：事务A读取到了事务B修改但未提交的数据。如果此时B回滚到修改之前的状态，A就读到了脏数据。
- 不可重复读：事务A多次读取同一个数据，此时事务B在A读取过程中对数据修改并提交了，导致事务A在同一个事务中多次读取同一数据而结果不同。
- 幻读：事务A对表进行修改，这个修改涉及到表中所有的行，但此时事务B新插入了一条数据，事务A就会发现居然还有数据没有被修改，就好像发生幻觉一样。

脏读是读取到事务未提交的数据，不可重复度读读取到的是提交提交后的数据，只不过在一次事务中读取结果不一样。

不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。

![821187-20160811171241606-133220585](http://picmeup.oss-cn-hangzhou.aliyuncs.com/coding/821187-20160811171241606-133220585.jpg)

一般来说，数据库隔离级别不一样，可能出现的并发问题也不同。级别最高的是串行化，所有问题都不会出现。但是在并发下性能极低，可重复读会只会导致幻读。

所以一般使用MySQL默认的可重复读即可。MVCC（多版本并发控制）使用undo_log使得事务可以读取到数据的快照（某个历史版本），从而实现了可重复读。MySQL采用Next-Key Lock算法，对于索引的扫描不仅是锁住扫描到的索引，还锁住了这些索引覆盖的范围，避免了不可重复读和幻读的产生。

#### 3、MySql数据库在什么情况下出现死锁？产生死锁的四个必要条件？如何解决死锁？

死锁是指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种互相等待的现象，若无外力作用两个事务都无法推进，这样就产生了死锁。下去 死锁的四个必要条件：

- 互斥条件：即任何时刻，一个资源只能被一个进程使用。其他进程必须等待。
- 请求和保持条件：即当资源请求者在请求其他的资源的同时保持对原有资源的占有且不释放。 
- 不剥夺条件：资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放。 
- 环路等待条件：比如A占有B在等待的资源（B等待A释放），B占有A在等待的资源（A等待B释放）。多个进程循环等待着相邻进程占用着的资源。

避免死锁可以通过破环四个必要条件之一。

解决死锁的方法：

- 加锁顺序保持一致。不同的加锁顺序很可能导致死锁，比如哲学家问题：A先申请筷子1在申请筷子2，而B先申请筷子2在申请筷子1，最后谁也得不到一双筷子（同时拥有筷子1和筷子2）
- 超时，为其中一个事务设置等待时间，若超过这个阈值事务就回滚，另一个等待的事务就能得以继续执行。
- 及时检测出死锁，回滚undo量最小的事务。一般是采用等待图（wait-for gragh）。采用深度优先搜索的算法实现，如果图中有环路就说明存在死锁。

#### 4、现在发现sql查询很慢，如何分析哪里出了问题，应该如何优化？

开启慢查询，查找哪些sql语句执行得慢。使用explain查看语句的执行计划，比如有没有使用到索引，是否启用了全表扫描等。查询慢，很大可能是因为没有使用索引或者索引没有被命中。还有其他的原因，比如发生了死锁，硬件、网速等原因。

优化手段：为相关列添加索引，并且确保索引可以被命中。优化sql语句的编写。

#### 5、索引的好处？

索引是对数据库表中一个或多个列的值进行排序的结构。MySql中索引是B+树，在查找时可以利用二分查找等高效率的查找方式，以O(lg n)的时间找到。因此索引可以加快查询速度。

#### 6、哪些情况需要建立索引？

- 在经常要搜索的列上
- 经常出现在where后面的列上
- 在作为主键的列上
- 作为外键的列上
- 经常需要排序、分组和联合操作的字段建立索引

哪些情况不适合建立索引？

- 查询中很少使用的字段
- 数值太少的字段
- 唯一性不太差的字段
- 更新频繁的字段
- 不会出现在where后的字段
- 索引适合建立在小字段上，text和blob等大字段不适合建立索引

#### 7、索引的最左匹配原则了解吗？

建了一个(a,b,c)的联合索引，那么实际等于建了(a),(a,b),(a,b,c)三个索引，但是有时在条件查询时只会匹配到a或者(a, b)而不会匹配到(a, b, c)。下面的例子

```sql
SELECT * FROM table WHERE a = 1 AND c = 3; // 使用了索引a，c不走索引
SELECT * FROM table WHERE a = 1 AND b < 2 AND c = 3; // 使用到了索引(a,b)，c不走索引
```

建立联合索引(a, b ,c)，所以索引是按照a -> b -> c的顺序进行排序的。a-b-c这样的索引是先找a，然后在范围里面找b，再在范围内找c。 所以上面的语句里的c 会分散在很多个b里面且不是排序的，所以没办法走索引。

举个例子比如(a, b)联合索引，先按a排序再按b排序，得到

```sql
(1,1)->(1, 2)->(2, 1)  (2, 4)->(3, 1)->(3, 2)
```

如果执行`select a from table where b=2`，就没有使用到(a, b)这个联合索引，因为b的值1,2,1,4,1,2显然不是排序的。

具体来说：MySQL会从左开始一直向右匹配直到遇到范围查询（>,<,BETWEEN,LIKE）就停止匹配，比如： a = 1 AND b = 2 AND c > 3 AND d = 4，如果建立 （a,b,c,d）顺序的索引，使用了索引(a, b, c)，但是d是没有走索引的，如果建立（a,b,d,c）的索引，则可以命中索引(a, b, c, d)，其中a,b,d的顺序可以任意调整。

等于（=）和in 可以乱序。比如，a = 1 AND b = 2 AND c = 3 建立（a,b,c）索引可以任意顺序。

#### 8、如何建立复合索引，可以使sql语句能尽可能匹配到索引？

- 等于条件的索引放在前面（最左），范围查询放在后面。` a = 1 AND b = 2 AND c > 3 AND d = 4`，建立（a, b, d, c）就是不错的选择；
- 先过滤后排序（ORDER BY）如`SELECT * FROM t WHERE c = 100 and d = 'xyz' ORDER BY b`建立(c, d, b)联合索引就是不错的选择
- 对于索引列的查询，一般不建议使用LIKE操作，像`LIKE '%abc'`这样的不能命中索引；不过`LIKE 'abc%'`可以命中索引。

#### 9、建立了索引，索引就一定会被命中吗？或者说索引什么时候失效

- 使用了`not in, <>,!=`则不会命中索引。注：`<>`是不等号
- innoDB引擎下，若使用OR，只有前后两个列都有索引才能命中（执行查询计划，type是index_merge），否则不会使用索引。
- 模糊查询中，通配符在最前面时，即`LIKE '%abc'`这样不能命中索引
- 对列进行函数运算的情况（如 where md5(password) = "xxxx"）
- 联合索引中，遇到范围查询时，其后的索引不会被命中
- 存了数字的char或varchar类型，常见的如用字符串表示的手机号，在查询时不加引号，则不会命中（如where phone=‘13340456789’能命中，where phone=13340456789不能命中）
- 当数据量小时，MySQL发现全表扫描反而比使用索引查询更快时不会使用索引。

#### 10、为什么要使用联合索引？

> MySQL5.0之前，一个表一次只能使用一个索引，无法同时使用多个索引分别进行条件扫描。但是从5.1开始，引入了 index merge 优化技术，对同一个表可以使用多个索引分别进行条件扫描。

[推荐阅读这篇博客](https://www.jianshu.com/p/XgXfhf)

- **减少开销**。建了一个(a,b,c)的联合索引，相当于建了(a),(a,b),(a,b,c)三个索引 
- **覆盖索引**。减少了随机IO操作。同样的有复合索引（a,b,c），如果有如下的sql: select a,b,c from table where a=1 and b = 1。那么MySQL可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机io操作
- **效率高**。索引列越多，通过索引筛选出的数据越少。比如有1000W条数据的表，有如下sql:select * from table where a = 1 and b =2 and c = 3,假设假设每个条件可以筛选出10%的数据，如果只有单值索引，那么通过该索引能筛选出1000W*10%=100w 条数据，然后再回表从100w条数据中找到符合b=2 and c= 3的数据，然后再排序，再分页；如果是复合索引，通过索引筛选出1000w *10% *10% *10%=1w，然后再排序、分页。

#### 11、既然索引可以加快查询速度，索引越多越好是吗？

[推荐阅读这篇优博客](https://www.jb51.net/article/81875.htm)

大多数情况下索引能大幅度提高查询效率，但数据的变更（增删改）都需要维护索引，因此更多的索引意味着更多的维护成本和更多的空间 （一本100页的书，却有50页目录？）而且过小的表，建立索引可能会更慢（读个2页的宣传手册，你还先去找目录？）

#### 12、主键和唯一索引的区别？

- 主键是一种约束，唯一索引是索引，一种数据结构。
- 主键一定是唯一索引，唯一索引不一定是主键。
- 一个表中可以有多个唯一索引，但只能有一个主键。
- 主键不允许空值，唯一索引允许。
- 主键可以做为[外键](https://www.baidu.com/s?wd=%E5%A4%96%E9%94%AE&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)，唯一索引不行； 

#### 13、B+树和B-树的区别？

B-树是一种平衡的多路查找树。2-3树和2-3-4树都是B-树的特例。一棵M阶的B-树，除了根结点外的其他非叶子结点，最多含有M-1对键和链接，最少含有M/2对键和链接。根结点可以少于M/2，但是也不能少于2对。

- 关键字集合分布在整颗树中
- 每个元素在该树中只出现一次，可能在叶子结点上，也可能在非叶子结点上。
- 搜索有可能在非叶子结点结束。
- 所有叶子结点位于同一层

B+树是B-树的变体，也是一种多路查找树。

- 非叶子结点值可以看作索引，仅含有其子树中的最大（或）最小关键字。
- 叶子结点保存了所有关键字，且叶子结点按照从小到大的顺序排列，是一个双向链表结构。
- 只能在叶子节点命中搜索

B+ 树更适合用于数据库和操作系统的文件系统中。 

假设一个结点就是一个页面，B树遍历所有记录，通过中序遍历的方式，要多次返回到父结点，同一个结点多次访问了，增加了磁盘I/O操作的次数。B+因为在叶子结点存放了所有的记录，而且是双向链表的结构，只需在叶子节点这一层就能遍历所有记录，大大减少了磁盘I/O操作，所以数据库索引用B+树结构更好。

#### 14、聚集索引与非聚集索引的区别？

- 对于聚集索引，表记录的排列顺序和与索引的排列顺序是一致的；非聚集索引不是
- 聚集索引就是按每张表的主键构造一棵B+树，每张表只能拥有一个聚集索引；一张表可以有多个非聚集索引
- 聚集索引的叶子结点存放的是整张表的行记录数据；非聚集索引的叶子结点并不包含行记录的全部数据，除了包含键值还包含一个书签——即相应行数据的聚集索引键。因此通过非聚集索引查找时，先根据叶子结点的指针获得指向主键索引的主键，然后再通过主键索引来找到一个完整的行记录。

#### 15、InnoDB和MyISAM引擎的区别？

- InnoDB支持事务，MyISAM不支持
- InnoDB是行锁设计，MyISAM是表锁设计
- InnoDB支持外键，MyISAM不支持
- InnoDB采用聚集的方式，每张表按照主键的顺序进行存放。如果没有主键，InnoDB会为每一行生成一个6字节的ROWID并以此为主键；MyISAM可以不指定主键和索引
- InnoDB没有保存表的总行数，因此查询行数时会遍历整表；而MyISAM有一个变量存储可表的总行数，查询时可以直接取出该值
- InnoDB适合联机事务处理(OLTP)，MyISAM适合联机分析处理(OLAP)

#### 16、`COUNT(*)`和`COUNT(1)`的区别？`COUNT(列名)`和`COUNT(*)`的区别？

`COUNT(*)`和`COUNT(1)`没区别。`COUNT(列名)`和`COUNT(*)`区别在于前者不会统计列为NULL的数据，后者会统计。 

#### 17、数据库中悲观锁和乐观锁讲一讲？

悲观锁：总是假设在并发下会出现问题，即假设多个事务对同一个数据的访问会产生冲突。当其他事务想要访问数据时，会在临界区提前加锁，需要将其阻塞挂起。比如MySQL中的排他锁（X锁）、和共享锁（S锁）

乐观锁： 总是假设任务在并发下是安全的，即假设多个事务对同一个数据的访问不会发生冲突，因此不会加锁，就对数据进行修改。当遇到冲突时，采用CAS或者版本号、时间戳的方式来解决冲突。数据库中使用的乐观锁是版本号或时间戳。乐观并发控制（OCC）是一种用来解决写-写冲突的无锁并发控制，不用加锁就尝试对数据进行修改，在修改之前先检查一下版本号，真正提交事务时，再检查版本号有，如果不相同说明已经被其他事务修改了，可以选择回滚当前事务或者重试；如果版本号相同，则可以修改。

 提一下乐观锁和MVCC的区别，其实MVCC也利用了版本号，和乐观锁还是能扯上些关系。

MVCC主要解决了读-写的阻塞，因为读只能读到数据的历史版本（快照）；OCC主要解决了写-写的阻塞，多个事务对数据进行修改而不加锁，更新失败的事务可以选择回滚或者重试。

>  当多个用户/进程/线程同时对数据库进行操作时，会出现3种冲突情形：读-读，不存在任何问题；读-写，有隔离性问题，可能遇到脏读、不可重复读 、幻读等。写-写，可能丢失更新。多版本并发控制（MVCC）是一种用来解决读-写冲突的无锁并发控制，读操作只读该事务开始前的数据库的快照，实现了一致性非锁定读。 这样在读操作不用阻塞写操作，写操作不用阻塞读操作的同时，避免了脏读和不可重复读。乐观并发控制（OCC）是一种用来解决写-写冲突的无锁并发控制，不用加锁就尝试对数据进行修改，在修改之前先检查一下版本号，真正提交事务时，再检查版本号有，如果不相同说明已经被其他事务修改了，可以选择回滚当前事务或者重试；如果版本号相同，则可以修改。 

#### 18、MySQL的可重复读是如何实现的？

MVCC（多版本并发控制）使用undo_log使得事务可以读取到数据的快照（某个历史版本），从而实现了可重复读。MySQL采用Next-Key Lock算法，对于索引的扫描不仅是锁住扫描到的索引，还锁住了这些索引覆盖的范围，避免了不可重复读和幻读的产生。

具体来说：

在可重复读下： select....from会采用MVCC实现的一致性非锁定读，读取的是事务开始的快照，避免了不可重复读。select .....from .... for update会采用 Next-Key Locking来保证可重复读和幻读。

在读已提交下: select....from 会采用快照，读取的是最新一份的快照数据，不能够保证不可重复读和幻读；select .....from .... for update会采用Record Lock，不能够保证不可重复读/幻读。 

#### 19、覆盖索引是什么？

如果一个索引包含(或覆盖)所有需要查询的字段的值，即只需扫描索引而无须回表，这称为“覆盖索引”。InnoDB的辅助索引在叶子节点中保存了部分键值信息以及指向聚集索引键的指针，如果辅助索引叶子结点中的键值信息已经覆盖了要查询的字段，就没有必要利用指向主键索引的主键，然后再通过主键索引来找到一个完整的行记录了。

#### 20、MySQL中JOIN和UNION什么区别？

UNION 操作符用于合并两个或多个 SELECT 语句的结果集。UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相同的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。默认情况下，UNION会过滤掉重复的值。使用 UNION ALL则会包含重复的值。

JOIN用于连接两个有关联的表，筛选两个表中满足条件（ON后的条件）的行记录得到一个结果集。从结果集中SELECT的字段可以是表A或者表B中的任意列。

JOIN常用的有LEFT JOIN、RIGHT JOIN、INNER JOIN。

- LEFT JOIN会以左表为基础，包含左表的所有记录，以及右表中匹配ON条件的记录，对于未匹配的列，会以NULL表示。
- LEFT JOIN会以右表为基础，包含左表的所有记录，以及右表匹配ON条件的记录，对于未匹配的列，会以NULL表示。
- INNER JOIN，产生两个表的交集（只包含满足ON条件的记录）

![231634008872011](http://picmeup.oss-cn-hangzhou.aliyuncs.com/coding/231634008872011.png)

INNER JOIN

![231634016379381](http://picmeup.oss-cn-hangzhou.aliyuncs.com/coding/231634016379381.png)

FULL OUTER JOIN

![231634027315181](http://picmeup.oss-cn-hangzhou.aliyuncs.com/coding/231634027315181.png)

![231634045743650](http://picmeup.oss-cn-hangzhou.aliyuncs.com/coding/231634045743650.png)

LEFT JOIN

![231634072774691](http://picmeup.oss-cn-hangzhou.aliyuncs.com/coding/231634072774691.png)

RIGHT JOIN和LEFT JOIN类似。

![241947220904425](http://picmeup.oss-cn-hangzhou.aliyuncs.com/coding/241947220904425.jpg)

#### 21、WHERE和HAVING的区别？

- WHERE过滤的是行，HAVING过滤分组。
- WHERE能完成的，都可以用HAVING(只是有时候没必要)
- WHERE在分组前对数据进行过滤，HAVING在分组后对数据进行过滤
- WHERE后不能接聚合函数，HAVING后面通常都有聚合函数

#### 22、SQL注入是什么，如何防止？

所谓SQL注入式攻击，就是攻击者把SQL命令插入到Web表单的输入域或页面请求的查询字符串，欺骗服务器执行恶意的SQL命令。

比如在登录界面，如果用户名填入`'xxx' OR 1=1 --`就能构造下面的SQL语句，因为OR 1=1，password被注释掉，因此无论name和password填入什么都能登录成功。

```sql
SELECT * FROM USER WHERE NAME='xxx' OR 1=1 -- and password='xxx';
```

使用PrepareStatement，可以防止sql注入攻击，sql的执行需要编译，注入问题之所以出现，是因为用户填写 sql语句参与了编译。使用PrepareStatement对象在执行sql语句时，会分为两步，第一步将sql语句 "运送" 到mysql上预编译，再回到java端拿到参数运送到mysql端。**预先编译好，也就是SQL引擎会预先进行语法分析，产生语法树，生成执行计划，也就是说，后面你输入的参数，无论你输入的是什么，都不会影响该sql语句的语法结构了。用户填写的 sql语句，就不会参与编译，只会当做参数来看。从而避免了sql注入问题。**
